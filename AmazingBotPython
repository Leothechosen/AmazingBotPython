# AmazingBotPython.py

import os
import random
from dotenv import load_dotenv
from discord.ext import commands
import requests
import pprint
import time
from datetime import datetime, timedelta
import threading
import discord
from pytz import timezone
import asyncio
import aiohttp
import random
import logging
import re


load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD = os.getenv('LEO_TEST_SERVER_NAME')
apikey = os.getenv('RIOT_API_KEY')
twitchtoken = os.getenv('TWITCH_API_KEY')
amazing = os.getenv('AMAZING_CHANNEL')
timechannel = os.getenv('SERVER_TIME_CHANNEL')
amazingserver = os.getenv('AMAZING_SERVER_NAME')
amazingserverid = int(os.getenv('AMAZING_SERVER_ID'))
servertimechannel = int(os.getenv('SERVER_TIME_CHANNEL'))
announcementchannel = int(os.getenv('AMAZING_ANNOUNCEMENT_ID'))
announcements = ["Go, get in there!", "Tune in and find out why they call him the Anaconda", "Come watch and soon you'll be Amazing yourself", "Don't knock him before you try him"]
moderators = ["365623187276300288","249856128756875265","163795280867753984","122919363656286212","188044536365187072"]
shitlist_file = './shitlist.txt'

bot = commands.Bot(command_prefix='-')
announcementchannel = None

@bot.event
async def on_ready():
	print(f'{bot.user.name} has connected to Discord')
	await theserverTime()
	
@bot.event
async def on_connect():
	await asyncio.sleep(10)
	await amazingLive()

@bot.group(pass_context=True)
async def league(ctx):
	if ctx.invoked_subcommand is None:
		await ctx.send("Subcommands are rank")
	return
	
@league.command(pass_context=True)
async def rank(ctx, name: str, region = None):
	embed = discord.Embed(title = name + "'s Ranks in " + region, color=0xa9152b)
	if region == None:
		await ctx.send("You did not specify a region")
		return;	
	region = region.upper()
	def region_to_valid_region(region: str):
		switcher = {
			'RU':'RU',
			'KR':'KR',
			'BR':'BR1',
			'OC':'OC1',
			'JP':'JP1',
			'NA':'NA1',
			'EUNE':'EUN1',
			'EUW':'EUW1',
			'TR':'TR1',
			'LAN':'LA1',
			'LAS':'LA2'
				}
		return switcher.get(region, "Invalid Region")
	region = region_to_valid_region(region)
	if region == "Invalid Region":
		ctx.send("The server you entered is invalid, or it's a Garena server")
	else:
		async with aiohttp.ClientSession() as session:
			async with session.get("https://" + region + ".api.riotgames.com/lol/summoner/v4/summoners/by-name/" + name + "?api_key=" + apikey) as response:
				if response.status != 200:
					await ctx.send("Riot API returned a bad request. Check for errors in your request, or tell Leo to reset his API key.")
					return;
				summoneridrequest = await response.json()
				summonerid = summoneridrequest['id']
			async with session.get("https://" + region + ".api.riotgames.com/lol/league/v4/entries/by-summoner/" + summonerid + "?api_key=" + apikey) as response:
				rankedrequest = await response.json()
			async with session.get("https://" + region + ".api.riotgames.com/tft/league/v1/entries/by-summoner/" + summonerid + "?api_key=" + apikey) as response:
				tftrequest = await response.json()
			await session.close()
			if rankedrequest != []:
					for x in range(len(rankedrequest)):
						if rankedrequest[x]["queueType"] == "RANKED_SOLO_5x5":
							message = ""
							message += (rankedrequest[x]["tier"] + " " + rankedrequest[x]["rank"] + " " + str(rankedrequest[x]["leaguePoints"]) + "LP ")
							if "miniSeries" in rankedrequest[x]:
								message += ("| Promo: ")
								for y in range(len(rankedrequest[x]["miniSeries"]["progress"])):
									if rankedrequest[x]["miniSeries"]["progress"][y] == 'W':
										message += (":white_check_mark:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "N":
										message += (":grey_question:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "L":
										message += (":x:")
							embed.add_field(name="Solo", value=message, inline=False)
						elif rankedrequest[x]["queueType"] == "RANKED_FLEX_SR":
							message = (rankedrequest[x]["tier"] + " " + rankedrequest[x]["rank"] + " " + str(rankedrequest[x]["leaguePoints"]) + "LP ")
							if "miniSeries" in rankedrequest[x]:
								message += ("| Promo: ")
								for y in range(len(rankedrequest[x]["miniSeries"]["progress"])):
									if rankedrequest[x]["miniSeries"]["progress"][y] == 'W':
										message += (":white_check_mark:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "N":
										message += (":grey_question:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "L":
										message += (":x:")
							embed.add_field(name="Flex", value=message, inline=False)
						else:
							continue
			if tftrequest != []:
				embed.add_field(name="TFT", value=tftrequest[0]["tier"] + " " + tftrequest[0]["rank"] + " " + str(tftrequest[0]["leaguePoints"]) + "LP",inline=True)
			if rankedrequest == [] and tftrequest == []:
				embed.add_field(name="Unranked", value=name + " is unranked in all queues")
		await ctx.send(embed=embed)

@bot.group(pass_context=True)
async def lor(ctx):
	if ctx.invoked_subcommand is None:
		await ctx.send("Subcommands are leaderboard")
	return

@lor.command(pass_context=True)
async def leaderboard(ctx, region = None):
	leaderboard_message = ""
	rank_message = ""
	embed = discord.Embed(title= "LoR Master Tier in " + region.title() , color=0xa9152b)
	print(region)
	async with aiohttp.ClientSession() as session:
			async with session.get("https://" + region + ".api.riotgames.com/lor/ranked/v1/leaderboards?api_key=" + apikey) as response:
				if response.status != 200:
					await ctx.send("Please specify a valid region (Americas, Asia, Europe)")
					return
				leaderboards = await response.json()
				for x in range(len(leaderboards["players"])):
					rank_message += str(x+1) + '\n'
				embed.add_field(name="Rank", value = rank_message, inline=True)
				for x in range(len(leaderboards["players"])):
					leaderboard_message += leaderboards["players"][x]["name"] + '\n'
				embed.add_field(name="Name", value = leaderboard_message, inline=True)
	await session.close()
	await ctx.send(embed=embed)	
	
@bot.group(pass_context=True, help = "Subcommands: standings and team")	
async def esports(ctx):
	if ctx.invoked_subcommand is None:
		await ctx.send("Subcommands are standings, team and schedule. See pinned message for usage.	")
	return
		
@esports.command(pass_context=True)
async def standings(ctx, tournament: str):
	embed = discord.Embed(title = tournament.upper() + " Standings", color=0xa9152b)
	ordinal_message = ""
	teams_message = ""
	records_message = ""
	tournamentId = await getTournamentId(tournament)
	if tournamentId == "Invalid League":
		await ctx.send("League not supported. Supported Leagues are: LCS, LEC, LCK, LPL, OPL, CBLOL, TCL, LJL, and LCSA(cademy)")
		return
	async with aiohttp.ClientSession() as session:
		headers = {'x-api-key': '0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z'}
		async with session.get("https://esports-api.lolesports.com/persisted/gw/getStandings?hl=en-US&tournamentId=" + tournamentId, headers=headers) as response:
			standings_response = await response.json()
			print(standings_response)
			rankings = (standings_response["data"]["standings"][0]["stages"][0]["sections"][0]["rankings"])
			for x in range(len(rankings)):
				ordinal = str(rankings[x]['ordinal'])
				def integerPrefix(ordinal):
					switcher = {
						"1":"1st",
						"2":"2nd",
						"3":"3rd",
						"4":"4th",
						"5":"5th",
						"6":"6th",
						"7":"7th",
						"8":"8th",
						"9":"9th",
						"10":"10th"
						}
					return switcher.get(ordinal, "???")
				ordinal = integerPrefix(ordinal)
				for y in range(len(rankings[x]["teams"])):
					ordinal_message += (ordinal + '\n')
			embed.add_field(name="Place", value=ordinal_message, inline=True)
			for x in range(len(rankings)):
				for y in range(len(rankings[x]["teams"])):
					teams_message += str(rankings[x]["teams"][y]["name"]) + '\n'
			embed.add_field(name="Team", value=teams_message, inline=True)
			for x in range(len(rankings)):
				for y in range(len(rankings[x]["teams"])):
					records_message += str(rankings[x]["teams"][y]["record"]["wins"]) + "-" + str(rankings[x]["teams"][y]["record"]["losses"]) + '\n'
			embed.add_field(name="Record", value=records_message, inline=True)
		await session.close()
	await ctx.send(embed=embed)

@esports.command(pass_context=True)
async def schedule(ctx, league: str):
	schedule_message = ""
	teams_message = ""
	embed = discord.Embed(title = league.upper() + " Schedule (Next 7 days)", color=0xa9152b)
	league = await getLeagueId(league)
	if league == "Invalid League":
		await ctx.send("League not supported. Supported Leagues are: LCS, LEC, LCK, LPL, OPL, CBLOL, TCL, LJL, and LCSA(cademy)")
		return
	async with aiohttp.ClientSession() as session:
		headers = {'x-api-key': '0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z'}
		async with session.get("https://esports-api.lolesports.com/persisted/gw/getSchedule?hl=en-US&leagueId=" + league, headers=headers) as response:
			schedule_response = await response.json()
			await session.close()
			currenttime = datetime.now(timezone('UTC')).strftime("%Y-%m-%d %H:%M:%S")
			currenttime = datetime.strptime(currenttime, "%Y-%m-%d %H:%M:%S")
			scheduled_matches = schedule_response["data"]["schedule"]["events"]
			for x in range(len(scheduled_matches)):
				if scheduled_matches[x]["state"] == "unstarted":
					starttime = re.sub('[T]', " ", scheduled_matches[x]["startTime"])
					starttime = re.sub('[Z]', "", starttime)
					starttime = datetime.strptime(starttime, "%Y-%m-%d %H:%M:%S")
					if currenttime + timedelta(days=7) > starttime:
						remainingtime = str(starttime - currenttime)
						print(remainingtime)
						if "day" in remainingtime: 
							remainingtime = remainingtime[:-6] + ' hours\n'
						else:
							if remainingtime[0:1] == '1:':
								remainingtime = remainingtime[0] + " hour, " + remainingtime[3:4] + " minutes\n"
							elif remainingtime[1] == ":":
								remainingtime = remainingtime[0] + " hours, " + remainingtime[3:5] + " minutes\n"
							else:
								remainingtime = remainingtime[0:2] + " hours, " + remainingtime[3:5] + " minutes\n"
						schedule_message += remainingtime
						teams_message += "**" + scheduled_matches[x]["match"]["teams"][0]["name"] + "**" + " vs " + "**" + scheduled_matches[x]["match"]["teams"][1]["name"] + '**\n'
			embed.add_field(name = "Time Remaining", value = schedule_message, inline = True)
			embed.add_field(name = "Teams", value = teams_message, inline = True)
		await ctx.send(embed=embed)
	
@esports.command(pass_context=True)
async def team(ctx, team: str):
	role_message = ""
	name_message = ""
	async with aiohttp.ClientSession() as session:
		headers = {'x-api-key': '0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z'}
		async with session.get("https://esports-api.lolesports.com/persisted/gw/getTeams?hl=en-US&id=" + team.lower(),headers=headers) as response:
			team_response = await response.json()
			await session.close()
			if team_response["data"]["teams"] == []:
				await ctx.send("Invalid team name. Double check spelling, or try something else (If you tried IMT for Immortals, try Immortals instead, or vice versa).")
				return
			embed = discord.Embed(title = team.upper() + " Roster", color=0xa9152b)
			names = team_response["data"]["teams"][0]["players"]
			for x in range(len(names)):
				role_message += (names[x]['role']).title() + '\n'
			embed.add_field(name="Role", value=role_message, inline=True)
			for x in range(len(names)):
				name_message += names[x]['firstName'] + " '" + names[x]['summonerName'] + "' " + names[x]['lastName'] + '\n'
			embed.add_field(name="Name", value=name_message, inline=True)
			embed.set_thumbnail(url=team_response["data"]["teams"][0]["image"])
	await ctx.send(embed=embed)

@bot.group(pass_context=True)
async def shitlist(ctx):
	if ctx.invoked_subcommand is None:
		if str(ctx.author.id) not in moderators:
			return
		shitlist = open(shitlist_file, 'r')
		await ctx.send(shitlist.read())
		shitlist.close()

@shitlist.command(pass_context=True)
async def add(ctx, name):
	if str(ctx.author.id) not in moderators:
		return
	shitlist = open(shitlist_file, 'a')
	shitlist.write(name+'\n')
	shitlist.close()
	await ctx.send("Addition successful")
	return
	
@shitlist.command(pass_context=True)
async def remove(ctx, name):
	if str(ctx.author.id) not in moderators:
		return
	shitlist = open(shitlist_file, 'r')
	names = shitlist.readlines()
	shitlist.close()
	shitlist = open(shitlist_file, 'w')
	for line in names:
		if line.strip("\n") != name:
			shitlist.write(line)
	return

@bot.command(name='poll')
async def poll(ctx, *, arguments):
	reaction_list = ['1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣', '6️⃣', '7️⃣', '8️⃣', '9️⃣']	
	answers = ""
	answers_vote = ""
	arguments = arguments.split(', ', 9)
	question = arguments[0].title()
	remainingseconds = 12
	if question[-1] != '?':
		question += '?'
	for x in range(len(arguments)):
		if x == 0:
			continue
		else:
			answers += str(x) + ": " + arguments[x].title() + '\n'
	embed = discord.Embed(title = "Question: " + question, color = 0xa9152b)
	embed.add_field(name = "Answers", value = answers, inline=False)
	embed.add_field(name = "Time Remaining", value = str(remainingseconds*5) + " seconds", inline=False)
	msg = await ctx.send(embed=embed)
	for x in range(len(arguments)):
		if x == len(arguments) - 1:
			continue
		else:
			await discord.Message.add_reaction(msg, reaction_list[x])	
	while remainingseconds >= 0:
		if remainingseconds == 0:
			embed.set_field_at(1, name = "Time Remaining", value = "Poll has finished", inline=False)
			await discord.Message.edit(msg, embed=embed)
			msg = await discord.User.fetch_message(ctx.channel, msg.id)
			reactors = {}
			print(msg.reactions[0].count)
			for react in msg.reactions:
				reactors.setdefault(react.count, [])
				reactors[react.count].append(react.emoji)
			print(reactors)
			max_reacts = max(reactors,key=int)
			if len(reactors[max_reacts]) != 1:
				tie_message = 'There was a tie between: "'
				for x in range(len(reactors[max_reacts])):
					if x != len(reactors[max_reacts]) - 1:
						tie_message += arguments[reaction_list.index(reactors[max_reacts][x])+1] + '" and "'
					else:
						tie_message += arguments[reaction_list.index(reactors[max_reacts][x])+1] + '"'
				embed.add_field(name = "Tie!", value = tie_message, inline=False)
			else:
				embed.add_field(name = "Winner", value = arguments[reaction_list.index(reactors[max_reacts][0])+1] + " wins!", inline=False)
			for x in range(len(arguments)):
				if x != 0:
					answers_vote += str(x) + ": " + arguments[x].title() + " - " + str(msg.reactions[x-1].count) + " votes\n"
			embed.set_field_at(0, name = "Answers",value = answers_vote, inline=False)
			await discord.Message.edit(msg, embed=embed)
			remainingseconds -= 1
		else:
			embed.set_field_at(1, name = "Time Remaining", value = str(remainingseconds*5) + " seconds", inline=False)
			await discord.Message.edit(msg, embed=embed)
			remainingseconds -= 1
			await asyncio.sleep(5)
	
@bot.command(name='sourcecode', help = "Links the source code to how I work!")
async def sourcecode(ctx):
	await ctx.send("https://www.github.com/Leothechosen/AmazingBotPython")
	
@bot.command(name='sub', help = "This command does nothing currently.")
async def sub(ctx):
	return
	
@bot.command(name='servertime')
async def restartservertime(ctx):
	await theserverTime()
	
async def getTournamentId(tournament):
	tournament = tournament.upper()
	switcher = {
		"LCS":"103462439438682788",
		"LEC":"103462459318635408",
		"LCK":"103540363364808496",
		"LPL":"103462420723438502",
		"OPL":"103535401218775284",	
		"CBLOL":"103478354329449186",
		"TCL":"103495775740097550",
		"LJL":"103540397353089204",
		"LCSA":"103462454280724883"
			}
	return switcher.get(tournament, "Invalid League")
	
async def getLeagueId(league):
	league = league.upper()
	switcher = {
		"EUM":"100695891328981122",
		"TAL":"101097443346691685",
		"LLA":"101382741235120470",
		"WORLDS":"98767975604431411",
		"ALL-STARS":"98767991295297326",
		"LCS":"98767991299243165",
		"LEC":"98767991302996019",
		"LCK":"98767991310872058",
		"LPL":"98767991314006698",
		"MSI":"98767991325878492",
		"OPL":"98767991331560952",
		"CBLOL":"98767991332355509",
		"TCL":"98767991343597634",
		"NAC":"98767991349120232",
		"LCSA":"99332500638116286",
		"LJL":"98767991349978712"
			}
	return switcher.get(league, "Invalid League")
			
async def theserverTime():
	minutecheck = datetime.now(timezone('CET'))
	fmt = '%H:%M %Z'
	fmt2 ='%s'
	minutecheck = minutecheck.strftime(fmt2)
	minutecheck = int(minutecheck)
	minutecheck = minutecheck % 60
	minutecheck = 61 - minutecheck
	await asyncio.sleep(minutecheck)
	while True:
		guild = discord.utils.get(bot.guilds, id = amazingserverid)
		servertime = discord.utils.get(guild.voice_channels, id = servertimechannel)
		berlin = datetime.now(timezone('CET'))
		berlin = berlin.strftime(fmt)
		await servertime.edit(name = berlin)
		await asyncio.sleep(60)
	
async def amazingLive():
	streamlive = True # Assume the stream is live
	guild = discord.utils.get(bot.guilds, id = amazingserverid)
	announcementchannel = discord.utils.get(guild.channels, name='announcements')
	while True:
		twitchrequest = twitchrequest = requests.get("https://api.twitch.tv/kraken/streams/" + amazing + "?api_verson=5", headers={"Accept": "application/vnd.twitchtv.v5+json", "Client-ID": twitchtoken})
		if twitchrequest.json()['stream'] == None and streamlive == True: #If not live while code thinks stream is live
			streamlive = False
			print("Amazing has gone offline")
			continue;
		elif twitchrequest.json()['stream'] != None and streamlive == False: #If live while code thinks stream isn't live
			await announcementchannel.send("@everyone " + random.choice(announcements) + " https://www.twitch.tv/amazingx")
			streamlive = True
			print("Amazing has gone online")
			continue;
		await asyncio.sleep(60)
		
bot.run(TOKEN)
