# AmazingBotPython.py

import os
import random
import time
import discord
import asyncio
import aiohttp
import re
import math
from pytz import timezone
from datetime import datetime, timedelta
from dotenv import load_dotenv
from discord.ext import commands	


load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD = os.getenv('LEO_TEST_SERVER_NAME')
apikey = os.getenv('RIOT_API_KEY')
twitchtoken = os.getenv('TWITCH_API_KEY')
amazing = os.getenv('AMAZING_CHANNEL')
timechannel = os.getenv('SERVER_TIME_CHANNEL')
amazingserver = os.getenv('AMAZING_SERVER_NAME')
amazingserverid = int(os.getenv('AMAZING_SERVER_ID'))
servertimechannel = int(os.getenv('SERVER_TIME_CHANNEL'))
announcementchannel = int(os.getenv('AMAZING_ANNOUNCEMENT_ID'))
announcements = ["Go, get in there!", "Tune in and find out why they call him the Anaconda", "Come watch and soon you'll be Amazing yourself", "Don't knock him before you try him"]
modlist_file = './modlist.txt'

bot = commands.Bot(command_prefix='-')
announcementchannel = None

@bot.event
async def on_ready():
	print(f'{bot.user.name} has connected to Discord')
	await theserverTime()
	
@bot.event
async def on_connect():
	await asyncio.sleep(10)
	await amazingLive()

@bot.group(pass_context=True)
async def league(ctx):
	if ctx.invoked_subcommand is None:
		await ctx.send("Subcommands are rank")
	return
	
@league.command(pass_context=True)
async def rank(ctx, name: str, region = None):
	embed = discord.Embed(title = name + "'s Ranks in " + region, color=0xa9152b)
	if region == None:
		await ctx.send("You did not specify a region")
		return;	
	region = region.upper()
	def region_to_valid_region(region: str):
		switcher = {
			'RU':'RU',
			'KR':'KR',
			'BR':'BR1',
			'OC':'OC1',
			'JP':'JP1',
			'NA':'NA1',
			'EUNE':'EUN1',
			'EUW':'EUW1',
			'TR':'TR1',
			'LAN':'LA1',
			'LAS':'LA2'
				}
		return switcher.get(region, "Invalid Region")
	region = region_to_valid_region(region)
	if region == "Invalid Region":
		ctx.send("The server you entered is invalid, or it's a Garena server")
	else:
		async with aiohttp.ClientSession() as session:
			async with session.get("https://" + region + ".api.riotgames.com/lol/summoner/v4/summoners/by-name/" + name + "?api_key=" + apikey) as response:
				if response.status != 200:
					await ctx.send("Riot API returned a bad request. Check for errors in your request, or tell Leo to reset his API key.")
					return;
				summoneridrequest = await response.json()
				summonerid = summoneridrequest['id']
			async with session.get("https://" + region + ".api.riotgames.com/lol/league/v4/entries/by-summoner/" + summonerid + "?api_key=" + apikey) as response:
				rankedrequest = await response.json()
			async with session.get("https://" + region + ".api.riotgames.com/tft/league/v1/entries/by-summoner/" + summonerid + "?api_key=" + apikey) as response:
				tftrequest = await response.json()
			await session.close()
			if rankedrequest != []:
					for x in range(len(rankedrequest)):
						if rankedrequest[x]["queueType"] == "RANKED_SOLO_5x5":
							message = ""
							message += (rankedrequest[x]["tier"] + " " + rankedrequest[x]["rank"] + " " + str(rankedrequest[x]["leaguePoints"]) + "LP ")
							if "miniSeries" in rankedrequest[x]:
								message += ("| Promo: ")
								for y in range(len(rankedrequest[x]["miniSeries"]["progress"])):
									if rankedrequest[x]["miniSeries"]["progress"][y] == 'W':
										message += (":white_check_mark:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "N":
										message += (":grey_question:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "L":
										message += (":x:")
							embed.add_field(name="Solo", value=message, inline=False)
						elif rankedrequest[x]["queueType"] == "RANKED_FLEX_SR":
							message = (rankedrequest[x]["tier"] + " " + rankedrequest[x]["rank"] + " " + str(rankedrequest[x]["leaguePoints"]) + "LP ")
							if "miniSeries" in rankedrequest[x]:
								message += ("| Promo: ")
								for y in range(len(rankedrequest[x]["miniSeries"]["progress"])):
									if rankedrequest[x]["miniSeries"]["progress"][y] == 'W':
										message += (":white_check_mark:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "N":
										message += (":grey_question:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "L":
										message += (":x:")
							embed.add_field(name="Flex", value=message, inline=False)
						else:
							continue
			if tftrequest != []:
				embed.add_field(name="TFT", value=tftrequest[0]["tier"] + " " + tftrequest[0]["rank"] + " " + str(tftrequest[0]["leaguePoints"]) + "LP",inline=True)
			if rankedrequest == [] and tftrequest == []:
				embed.add_field(name="Unranked", value=name + " is unranked in all queues")
		await ctx.send(embed=embed)

@bot.group(pass_context=True)
async def lor(ctx):
	if ctx.invoked_subcommand is None:
		await ctx.send("Subcommands are leaderboard")
	return

@lor.command(pass_context=True)
async def leaderboard(ctx, region = None):
	leaderboard_message = ""
	rank_message = ""
	valid_regions = ["americas", "europe", "asia"]
	if region == None:
		await ctx.send("Usage: `-lor leaderboards [region]`. Supported regions are: Americas, Asia, Europe")
		return
	if region.lower() not in valid_regions:
		await ctx.send("Invalid region. Supported regions are: Americas, Asia, Europe")
		return
	embed = discord.Embed(title= "LoR Master Tier in " + region.title() , color=0xa9152b)
	async with aiohttp.ClientSession() as session:
			async with session.get("https://" + region + ".api.riotgames.com/lor/ranked/v1/leaderboards?api_key=" + apikey) as response:
				if response.status != 200:
					await ctx.send("Riot API returned a bad request. Check for errors, or tell Leo to reset his API key.")
					return
				leaderboards = await response.json()
				for x in range(len(leaderboards["players"])):
					rank_message += str(x+1) + '\n'
				embed.add_field(name="Rank", value = rank_message, inline=True)
				for x in range(len(leaderboards["players"])):
					leaderboard_message += leaderboards["players"][x]["name"] + '\n'
				embed.add_field(name="Name", value = leaderboard_message, inline=True)
	await session.close()
	await ctx.send(embed=embed)	
	
@bot.group(pass_context=True, help = "Subcommands: standings and team")	
async def esports(ctx):
	if ctx.invoked_subcommand is None:
		await ctx.send("Subcommands are standings, team and schedule. See pinned message for usage.	")
	return
		
@esports.command(pass_context=True)
async def standings(ctx, tournament = None):
	embed = discord.Embed(title = tournament.upper() + " Standings", color=0xa9152b)
	ordinal_message = ""
	teams_message = ""
	records_message = ""
	if tournament == None:
		await ctx.send("Usage: `-esports standings [league]`. Supported Leagues are: LCS, LEC, LCK, LPL, OPL, CBLOL, TCL, LJL, and LCSA(cademy)")
		return
	tournamentId = await getTournamentId(tournament)
	if tournamentId == "Invalid League":
		await ctx.send("League not supported. Supported Leagues are: LCS, LEC, LCK, LPL, OPL, CBLOL, TCL, LJL, and LCSA(cademy)")
		return
	async with aiohttp.ClientSession() as session:
		headers = {'x-api-key': '0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z'}
		async with session.get("https://esports-api.lolesports.com/persisted/gw/getStandings?hl=en-US&tournamentId=" + tournamentId, headers=headers) as response:
			standings_response = await response.json()
			print(standings_response)
			rankings = (standings_response["data"]["standings"][0]["stages"][0]["sections"][0]["rankings"])
			for x in range(len(rankings)):
				ordinal = str(rankings[x]['ordinal'])
				def integerPrefix(ordinal):
					switcher = {
						"1":"1st",
						"2":"2nd",
						"3":"3rd",
						"4":"4th",
						"5":"5th",
						"6":"6th",
						"7":"7th",
						"8":"8th",
						"9":"9th",
						"10":"10th"
						}
					return switcher.get(ordinal, "???")
				ordinal = integerPrefix(ordinal)
				for y in range(len(rankings[x]["teams"])):
					ordinal_message += (ordinal + '\n')
			embed.add_field(name="Place", value=ordinal_message, inline=True)
			for x in range(len(rankings)):
				for y in range(len(rankings[x]["teams"])):
					teams_message += str(rankings[x]["teams"][y]["name"]) + '\n'
			embed.add_field(name="Team", value=teams_message, inline=True)
			for x in range(len(rankings)):
				for y in range(len(rankings[x]["teams"])):
					records_message += str(rankings[x]["teams"][y]["record"]["wins"]) + "-" + str(rankings[x]["teams"][y]["record"]["losses"]) + '\n'
			embed.add_field(name="Record", value=records_message, inline=True)
		await session.close()
	await ctx.send(embed=embed)

@esports.command(pass_context=True)
async def schedule(ctx, league = None):
	schedule_message = ""
	teams_message = ""
	if league == None:
		await ctx.send("Usage: `-esports schedule [league]`. Supported leagues are: LCS, LEC, LLCK, LPL, OPL, CBLOL, TCL, LJL, and LCSA(cademy)")
		return
	league = await sanitizeinput(league)
	embed = discord.Embed(title = league.upper() + " Schedule (Next 7 days)", color=0xa9152b)
	league = await getLeagueId(league)
	if league == "Invalid League":
		await ctx.send("League not supported. Supported Leagues are: LCS, LEC, LCK, LPL, OPL, CBLOL, TCL, LJL, and LCSA(cademy)")
		return
	async with aiohttp.ClientSession() as session:
		headers = {'x-api-key': '0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z'}
		async with session.get("https://esports-api.lolesports.com/persisted/gw/getSchedule?hl=en-US&leagueId=" + league, headers=headers) as response:
			schedule_response = await response.json()
			await session.close()
			currenttime = datetime.now(timezone('UTC')).strftime("%Y-%m-%d %H:%M:%S")
			currenttime = datetime.strptime(currenttime, "%Y-%m-%d %H:%M:%S")
			scheduled_matches = schedule_response["data"]["schedule"]["events"]
			for x in range(len(scheduled_matches)):
				if scheduled_matches[x]["state"] == "unstarted":
					starttime = re.sub('[T]', " ", scheduled_matches[x]["startTime"])
					starttime = re.sub('[Z]', "", starttime)
					starttime = datetime.strptime(starttime, "%Y-%m-%d %H:%M:%S")
					if currenttime + timedelta(days=7) > starttime:
						remainingtime = str(starttime - currenttime)
						print(remainingtime)
						if "day" in remainingtime: 
							remainingtime = remainingtime[:-6] + ' hours\n'
						else:
							if remainingtime[0:1] == '1:':
								remainingtime = remainingtime[0] + " hour, " + remainingtime[3:4] + " minutes\n"
							elif remainingtime[1] == ":":
								remainingtime = remainingtime[0] + " hours, " + remainingtime[3:5] + " minutes\n"
							else:
								remainingtime = remainingtime[0:2] + " hours, " + remainingtime[3:5] + " minutes\n"
						schedule_message += remainingtime
						teams_message += "**" + scheduled_matches[x]["match"]["teams"][0]["name"] + "**" + " vs " + "**" + scheduled_matches[x]["match"]["teams"][1]["name"] + '**\n'
			embed.add_field(name = "Time Remaining", value = schedule_message, inline = True)
			embed.add_field(name = "Teams", value = teams_message, inline = True)
		await ctx.send(embed=embed)
	
@esports.command(pass_context=True)
async def team(ctx, team = None):
	role_message = ""
	name_message = ""
	if team == None:
		await ctx.send("Usage: `-esports team [team]. Example: -esports team TSM`. If the team has spaces, replace the spaces with dashes. For example: Counter-Logic-Gaming")
		return
	team = await sanitizeinput(team)
	async with aiohttp.ClientSession() as session:
		headers = {'x-api-key': '0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z'}
		async with session.get("https://esports-api.lolesports.com/persisted/gw/getTeams?hl=en-US&id=" + team.lower(),headers=headers) as response:
			team_response = await response.json()
			await session.close()
			if team_response["data"]["teams"] == []:
				await ctx.send("Invalid team name. If the team has spaces, replace the spaces with dashes. For example: Counter-Logic-Gaming. Otherwise, check spelling, or try an abbreviation, e.g TSM")
				return
			embed = discord.Embed(title = team.upper() + " Roster", color=0xa9152b)
			names = team_response["data"]["teams"][0]["players"]
			for x in range(len(names)):
				role_message += (names[x]['role']).title() + '\n'
			embed.add_field(name="Role", value=role_message, inline=True)
			for x in range(len(names)):
				name_message += names[x]['firstName'] + " '" + names[x]['summonerName'] + "' " + names[x]['lastName'] + '\n'
			embed.add_field(name="Name", value=name_message, inline=True)
			embed.set_thumbnail(url=team_response["data"]["teams"][0]["image"])
	await ctx.send(embed=embed)

@bot.group(pass_context=True)
async def modlist(ctx):
	if ctx.invoked_subcommand is None:
		ismod = await moderatorcheck(ctx)
		if ismod != True:
			return
		modlist = open(modlist_file, 'r')
		await ctx.send(modlist.read())
		modlist.close()
	return

@modlist.command(pass_context=True)
async def add(ctx, name = None):
	ismod = await moderatorcheck(ctx)
	if ismod != True or name == None:
		return
	modlist = open(modlist_file, 'a')
	modlist.write(name+'\n')
	modlist.close()
	await ctx.send("Addition successful")
	return
	
@modlist.command(pass_context=True)
async def remove(ctx, name = None):
	ismod = await moderatorcheck(ctx)
	if ismod != True or name == None:
		return
	modlist = open(modlist_file, 'r')
	names = modlist.readlines()
	modlist.close()
	modlist = open(modlist_file, 'w')
	for line in names:
		if line.strip("\n") != name:
			modlist.write(line)
	modlist.close()
	return

@bot.command(name='poll')
async def poll(ctx, *, arguments):
	reaction_list = ['1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣', '6️⃣', '7️⃣', '8️⃣', '9️⃣']	
	answers = ""
	answers_vote = ""
	arguments = arguments.split(',', 10)
	for x in range(len(arguments)):
		arguments[x] = arguments[x].strip()
	question = arguments[0].title()
	remainingseconds = 0
	timeremaining = 0
	try:
		int(arguments[-1])
	except ValueError:
		await ctx.send("The last argument sent needs to be an integer indicating how long the poll should last in seconds (Max:300, rounded to the nearest 5 otherwise)")
	if int(arguments[-1]) > 300:
		await ctx.send("Poll timer has been set to the maximum value of 300 seconds")
		remainingseconds = 300
	else:
		remainingseconds = round(int(arguments[-1])/5)*5 #Rounds to a multple of 5
	del arguments[-1]
	if question[-1] != '?':
		question += '?'
	for x in range(len(arguments)):
		if x == 0:
			continue
		else:
			answers += str(x) + ": " + arguments[x].title() + '\n'
	embed = discord.Embed(title = "Question: " + question, color = 0xa9152b)
	embed.add_field(name = "Answers", value = answers, inline=True)
	if remainingseconds >= 60:
		timeremaining = str(int(remainingseconds/60)) + " minutes, " + str(remainingseconds%60) + " seconds"
	else:
		timeremaining = str(remainingseconds%60) + " seconds"
	embed.add_field(name = "Time Remaining", value = timeremaining, inline=False)
	msg = await ctx.send(embed=embed)
	for x in range(len(arguments)):
		if x == len(arguments) - 1:
			continue
		else:
			await discord.Message.add_reaction(msg, reaction_list[x])	
	while remainingseconds != "done":
		if remainingseconds <= 0:
			embed.set_field_at(1, name = "Time Remaining", value = "Poll has finished", inline=False)
			await discord.Message.edit(msg, embed=embed)
			msg = await discord.User.fetch_message(ctx.channel, msg.id)
			reactors = {}
			for react in msg.reactions:
				if react.emoji in reaction_list:
					reactors.setdefault(react.count, [])
					reactors[react.count].append(react.emoji)
			max_reacts = max(reactors,key=int)
			if len(reactors[max_reacts]) != 1:
				if max_reacts == 1:
					tie_message = "There were no votes cast"
				else:
					tie_message = 'There was a tie between: "'
					for x in range(len(reactors[max_reacts])):
						if x != len(reactors[max_reacts]) - 1:
							tie_message += arguments[reaction_list.index(reactors[max_reacts][x])+1] + '" and "'
						else:
							tie_message += arguments[reaction_list.index(reactors[max_reacts][x])+1] + '"'
				embed.add_field(name = "Tie!", value = tie_message, inline=False)
			else:
				embed.add_field(name = "Winner", value = arguments[reaction_list.index(reactors[max_reacts][0])+1] + " wins!", inline=False)
			for x in range(len(msg.reactions)):
				if msg.reactions[x].emoji in reaction_list:
					if msg.reactions[x].count == 2:
						answers_vote += str(msg.reactions[x].count-1) + " vote\n"
					else:
						answers_vote += str(msg.reactions[x].count-1) + " votes\n"
			embed.insert_field_at(1, name = "Votes", value = answers_vote, inline=True)
			await discord.Message.edit(msg, embed=embed)
			await discord.Message.clear_reactions(msg)
			remainingseconds = "done"
		else:
			timeremaining = 0
			if remainingseconds >= 60:
				timeremaining = str(int(remainingseconds/60)) + " minutes, " + str(remainingseconds%60) + " seconds"
			else:
				timeremaining = str(remainingseconds%60) + " seconds"
			embed.set_field_at(1, name = "Time Remaining", value = timeremaining, inline=False)
			await discord.Message.edit(msg, embed=embed)
			remainingseconds -= 5
			await asyncio.sleep(5)
	
@bot.command(name='sourcecode', help = "Links the source code to how I work!")
async def sourcecode(ctx):
	await ctx.send("https://www.github.com/Leothechosen/AmazingBotPython")
	
@bot.command(name='sub', help = "This command does nothing currently.")
async def sub(ctx):
	return
	
@bot.command(name='restartservertime')
async def restartservertime(ctx):
	ismod = await moderatorcheck(ctx)
	if ismod != True:
		return
	await ctx.send("Restarting the clock...")
	await theserverTime()
	
async def getTournamentId(tournament):
	tournament = tournament.upper()
	switcher = {
		"LCS":"103462439438682788",
		"LEC":"103462459318635408",
		"LCK":"103540363364808496",
		"LPL":"103462420723438502",
		"OPL":"103535401218775284",	
		"CBLOL":"103478354329449186",
		"TCL":"103495775740097550",
		"LJL":"103540397353089204",
		"LCSA":"103462454280724883"
			}
	return switcher.get(tournament, "Invalid League")
	
async def getLeagueId(league):
	league = league.upper()
	switcher = {
		"EUM":"100695891328981122",
		"TAL":"101097443346691685",
		"LLA":"101382741235120470",
		"WORLDS":"98767975604431411",
		"ALL-STARS":"98767991295297326",
		"LCS":"98767991299243165",
		"LEC":"98767991302996019",
		"LCK":"98767991310872058",
		"LPL":"98767991314006698",
		"MSI":"98767991325878492",
		"OPL":"98767991331560952",
		"CBLOL":"98767991332355509",
		"TCL":"98767991343597634",
		"NAC":"98767991349120232",
		"LCSA":"99332500638116286",
		"LJL":"98767991349978712"
			}
	return switcher.get(league, "Invalid League")
			
async def theserverTime():
	minutecheck = datetime.now(timezone('CET'))
	fmt = '%H:%M %Z'
	fmt2 ='%s'
	minutecheck = minutecheck.strftime(fmt2)
	minutecheck = int(minutecheck)
	minutecheck = minutecheck % 60
	minutecheck = 61 - minutecheck
	await asyncio.sleep(minutecheck)
	while True:
		guild = discord.utils.get(bot.guilds, id = amazingserverid)
		servertime = discord.utils.get(guild.voice_channels, id = servertimechannel)
		berlin = datetime.now(timezone('CET'))
		berlin = berlin.strftime(fmt)
		await servertime.edit(name = berlin)
		await asyncio.sleep(60)
	
async def amazingLive():
	streamlive = True # Assume the stream is live
	guild = discord.utils.get(bot.guilds, id = amazingserverid)
	announcementchannel = discord.utils.get(guild.channels, name='announcements')
	while True:
		async with aiohttp.ClientSession() as session:
			headers = {"Accept": "application//vnd.twitchtv.v5+json", "Client-ID": twitchtoken}
			async with session.get("https://api.twitch.tv/kraken/streams/" + amazing + "?api_verson=5", headers=headers) as response:
				twitchrequest = await response.json()
			await session.close()
		if twitchrequest['stream'] == None and streamlive == True: #If not live while code thinks stream is live
			streamlive = False
			print("Amazing has gone offline")
			continue;
		elif twitchrequest['stream'] != None and streamlive == False: #If live while code thinks stream isn't live
			await announcementchannel.send("@everyone " + random.choice(announcements) + " https://www.twitch.tv/amazingx")
			streamlive = True
			print("Amazing has gone online")
			continue;
		await asyncio.sleep(60)

async def sanitizeinput(inputs):
	return re.sub(r'[^a-zA-Z-]', "", inputs)
	
async def moderatorcheck(ctx):
	moderatorRole = discord.utils.get(ctx.message.guild.roles, name = "Moderators")
	if moderatorRole in ctx.author.roles:
		return True
	
bot.run(TOKEN)
