# AmazingBotPython.py

import os
import random
from dotenv import load_dotenv
from discord.ext import commands
import requests
import pprint
import time
from datetime import datetime
import threading
import discord
from pytz import timezone
import asyncio
import aiohttp
import random
import logging  

load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD = os.getenv('LEO_TEST_SERVER_NAME')
apikey = os.getenv('RIOT_API_KEY')
twitchtoken = os.getenv('TWITCH_API_KEY')
amazing = os.getenv('AMAZING_CHANNEL')
leo = os.getenv('LEO_CHANNEL')
leotext = os.getenv('LEO_TEST_TEXT')
leovoice = os.getenv('LEO_TEST_VOICE')
timechannel = os.getenv('SERVER_TIME_CHANNEL')
amazingserver = os.getenv('AMAZING_SERVER_NAME')
leoserver = os.getenv('LEO_TEST_SERVER_NAME')
announcements = ["Go, get in there!", "Tune in and find out why they call him the Anaconda", "Come watch and soon you'll be Amazing yourself", "Don't knock him before you try him"]
moderators = ["365623187276300288","249856128756875265","163795280867753984","122919363656286212","188044536365187072"]
shitlist_file = './shitlist.txt'

bot = commands.Bot(command_prefix='-')
servertimechannel = None
announcementchannel = None

@bot.event
async def on_ready():
	print(f'{bot.user.name} has connected to Discord')
	await theserverTime()
	
@bot.event
async def on_connect():
	await asyncio.sleep(10)
	await amazingLive()

@bot.command(name='rank', help = "-rank [Summoner_Name] [region] will return your rank")
async def rank(ctx, name: str, region = None):
	embed = discord.Embed(title = name + "'s Ranks in " + region, color=0xa9152b)
	if region == None:
		await ctx.send("You did not specify a region")
		return;	
	region = region.upper()
	def region_to_valid_region(region: str):
		switcher = {
			'RU':'RU',
			'KR':'KR',
			'BR':'BR1',
			'OC':'OC1',
			'JP':'JP1',
			'NA':'NA1',
			'EUNE':'EUN1',
			'EUW':'EUW1',
			'TR':'TR1',
			'LAN':'LA1',
			'LAS':'LA2'
				}
		return switcher.get(region, "Invalid Region")
	region = region_to_valid_region(region)
	if region == "Invalid Region":
		ctx.send("The server you entered is invalid, or it's a Garena server")
	else:
		async with aiohttp.ClientSession() as session:
			async with session.get("https://" + region + ".api.riotgames.com/lol/summoner/v4/summoners/by-name/" + name + "?api_key=" + apikey) as response:
				if response.status != 200:
					await ctx.send("Riot API returned a bad request. Check for errors in your request, or tell Leo to reset his API key.")
					return;
				summoneridrequest = await response.json()
				summonerid = summoneridrequest['id']
			async with session.get("https://" + region + ".api.riotgames.com/lol/league/v4/entries/by-summoner/" + summonerid + "?api_key=" + apikey) as response:
				rankedrequest = await response.json()
			async with session.get("https://" + region + ".api.riotgames.com/tft/league/v1/entries/by-summoner/" + summonerid + "?api_key=" + apikey) as response:
				tftrequest = await response.json()
			await session.close()
			if rankedrequest != []:
					for x in range(len(rankedrequest)):
						if rankedrequest[x]["queueType"] == "RANKED_SOLO_5x5":
							message = ""
							message += (rankedrequest[x]["tier"] + " " + rankedrequest[x]["rank"] + " " + str(rankedrequest[x]["leaguePoints"]) + "LP ")
							if "miniSeries" in rankedrequest[x]:
								message += ("| Promo: ")
								for y in range(len(rankedrequest[x]["miniSeries"]["progress"])):
									if rankedrequest[x]["miniSeries"]["progress"][y] == 'W':
										message += (":white_check_mark:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "N":
										message += (":grey_question:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "L":
										message += (":x:")
							embed.add_field(name="Solo", value=message, inline=False)
						elif rankedrequest[x]["queueType"] == "RANKED_FLEX_SR":
							message = (rankedrequest[x]["tier"] + " " + rankedrequest[x]["rank"] + " " + str(rankedrequest[x]["leaguePoints"]) + "LP ")
							if "miniSeries" in rankedrequest[x]:
								message += ("| Promo: ")
								for y in range(len(rankedrequest[x]["miniSeries"]["progress"])):
									if rankedrequest[x]["miniSeries"]["progress"][y] == 'W':
										message += (":white_check_mark:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "N":
										message += (":grey_question:")
									elif rankedrequest[x]["miniSeries"]["progress"][y] == "L":
										message += (":x:")
							embed.add_field(name="Flex", value=message, inline=False)
						else:
							continue
			if tftrequest != []:
				embed.add_field(name="TFT", value=tftrequest[0]["tier"] + " " + tftrequest[0]["rank"] + " " + str(tftrequest[0]["leaguePoints"]) + "LP",inline=True)
			if rankedrequest == [] and tftrequest == []:
				embed.add_field(name="Unranked", value=name + " is unranked in all queues")
		await ctx.send(embed=embed)
	
@bot.command(name='sourcecode', help = "Links the source code to how I work!")
async def sourcecode(ctx):
	await ctx.send("https://www.github.com/Leothechosen/AmazingBotPython")
	
@bot.command(name='sub', help = "Assigns subrole if Twitch integration is one AND user is subbed to Amazing")
async def sub(ctx):
	return

@bot.group(pass_context=True)	
async def esports(ctx):
	if ctx.invoked_subcommand is None:
		await ctx.send("How did you find this command? This command is under construction.")
	return
		
@esports.command(pass_context=True)
async def standings(ctx, league: str):
	league = league.upper()
	embed = discord.Embed(title = league, color=0xa9152b)
	ordinal_message = ""
	teams_message = ""
	records_message = ""
	def leagueId(league):
		switcher = {
			"LCS":"103462439438682788",
			"LEC":"103462459318635408",
			"LCK":"103540363364808496",
			"LPL":"103462420723438502",
			"OPL":"103535401218775284",
			"CBLOL":"103478354329449186",
			"TCL":"103495775740097550",
			"LJL":"103540397353089204",
			"LCSA":"103462454280724883"
				}
		return switcher.get(league, "Invalid League")
	league = leagueId(league)
	if league == "Invalid League":
		await ctx.send("League not supported. Supported Leagues are: LCS, LEC, LCK, LPL, OPL, CBLOL, TCL, LJL, and LCSA(cademy)")
		return
	async with aiohttp.ClientSession() as session:
		headers = {'x-api-key': '0TvQnueqKa5mxJntVWt0w4LpLfEkrV1Ta8rQBb9Z'}
		async with session.get("https://esports-api.lolesports.com/persisted/gw/getStandings?hl=en-US&tournamentId=" + league, headers=headers) as response:
			esports_response = await response.json()
			rankings = (esports_response["data"]["standings"][0]["stages"][0]["sections"][0]["rankings"])
			for x in range(len(rankings)):
				ordinal = str(rankings[x]['ordinal'])
				def integerPrefix(ordinal):
					switcher = {
						"1":"1st",
						"2":"2nd",
						"3":"3rd",
						"4":"4th",
						"5":"5th",
						"6":"6th",
						"7":"7th",
						"8":"8th",
						"9":"9th",
						"10":"10th"
						}
					return switcher.get(ordinal, "???")
				ordinal = integerPrefix(ordinal)
				for y in range(len(rankings[x]["teams"])):
					ordinal_message += (ordinal + '\n')
					#teams = rankings[x]["teams"][y]["name"]
					#message += ordinal + "  |  " + str(teams) + "  |  " + str(rankings[x]["teams"][y]["record"]["wins"]) + "-" + str(rankings[x]["teams"][y]["record"]["losses"]) + "\n"
			embed.add_field(name="Place", value=ordinal_message, inline=True)
			for x in range(len(rankings)):
				for y in range(len(rankings[x]["teams"])):
					teams_message += str(rankings[x]["teams"][y]["name"]) + '\n'
			embed.add_field(name="Team", value=teams_message, inline=True)
			for x in range(len(rankings)):
				for y in range(len(rankings[x]["teams"])):
					records_message += str(rankings[x]["teams"][y]["record"]["wins"]) + "-" + str(rankings[x]["teams"][y]["record"]["losses"]) + '\n'
			embed.add_field(name="Record", value=records_message, inline=True)
		await session.close()
	await ctx.send(embed=embed)

@bot.command(name='servertime')
async def restartservertime(ctx):
	await theserverTime()

@bot.group(pass_context=True)
async def shitlist(ctx):
	if ctx.invoked_subcommand is None:
		if str(ctx.author.id) not in moderators:
			return
		shitlist = open(shitlist_file, 'r')
		await ctx.send(shitlist.read())
		shitlist.close()

@shitlist.command(pass_context=True)
async def add(ctx, name):
	if str(ctx.author.id) not in moderators:
		return
	shitlist = open(shitlist_file, 'a')
	shitlist.write(name+'\n')
	shitlist.close()
	await ctx.send("Addition successful")
	return
	
@shitlist.command(pass_context=True)
async def remove(ctx, name):
	if str(ctx.author.id) not in moderators:
		return
	shitlist = open(shitlist_file, 'r')
	names = shitlist.readlines()
	shitlist.close()
	shitlist = open(shitlist_file, 'w')
	for line in names:
		if line.strip("\n") != name:
			shitlist.write(line)
	return
	
async def theserverTime():
	minutecheck = datetime.now(timezone('CET'))
	fmt = '%H:%M %Z'
	fmt2 ='%s'
	minutecheck = minutecheck.strftime(fmt2)
	minutecheck = int(minutecheck)
	minutecheck = minutecheck % 60
	minutecheck = 61 - minutecheck
	await asyncio.sleep(minutecheck)
	while True:
		guild = discord.utils.get(bot.guilds, name = amazingserver)
		servertimechannel = discord.utils.get(guild.voice_channels)
		berlin = datetime.now(timezone('CET'))
		berlin = berlin.strftime(fmt)
		await servertimechannel.edit(name = berlin)
		await asyncio.sleep(60)
	
async def amazingLive():
	streamlive = True # Assume the stream is live
	guild = discord.utils.get(bot.guilds, name = amazingserver)
	announcementchannel = discord.utils.get(guild.channels, name='announcements')
	while True:
		twitchrequest = twitchrequest = requests.get("https://api.twitch.tv/kraken/streams/" + amazing + "?api_verson=5", headers={"Accept": "application/vnd.twitchtv.v5+json", "Client-ID": twitchtoken})
		if twitchrequest.json()['stream'] == None and streamlive == True: #If not live while code thinks stream is live
			streamlive = False
			print("Amazing has gone offline")
			continue;
		elif twitchrequest.json()['stream'] != None and streamlive == False: #If live while code thinks stream isn't live
			await announcementchannel.send("@everyone " + random.choice(announcements) + " https://www.twitch.tv/amazingx")
			streamlive = True
			print("Amazing has gone online")
			continue;
		await asyncio.sleep(60)
		
bot.run(TOKEN)
